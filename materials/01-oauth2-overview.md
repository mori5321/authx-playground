# 第1章: OAuth 2.0 の全体像

## OAuth 2.0 とは何か

OAuth 2.0 は**認可 (Authorization)** のためのフレームワークである（RFC 6749）。認証 (Authentication) とは異なり、「誰であるか」ではなく「何を許可するか」を扱う。

具体例：ユーザーが写真管理アプリに対して「Google Drive 内の写真フォルダだけ読み取っていいよ」と許可を与える仕組み。アプリは Google のパスワードを知る必要がない。

## 登場人物 (Roles)

OAuth 2.0 には4つのロールが登場する。

```
+-------------------+          +-------------------+
| Resource Owner    |          | Client            |
| (ユーザー)        |          | (アプリケーション)  |
+-------------------+          +-------------------+
        |                              |
        |  認可を与える                 |  認可を使ってアクセス
        v                              v
+-------------------+          +-------------------+
| Authorization     |          | Resource Server   |
| Server (認可SV)   |          | (リソースSV)      |
+-------------------+          +-------------------+
```

| ロール | 説明 | 今回の実装対象 |
|--------|------|---------------|
| Resource Owner | リソースの所有者。通常はエンドユーザー | ブラウザ上のユーザーとして登場 |
| Client | リソースにアクセスしたいアプリケーション | テスト用クライアントアプリを作成 |
| Authorization Server | 認可を管理し、トークンを発行するサーバー | **これを自作する** |
| Resource Server | 保護されたリソースを提供するサーバー | 簡易的な API サーバーを作成 |

## プロトコルの全体フロー

```
     +--------+                               +---------------+
     |        |--(A)- Authorization Request ->|   Resource    |
     |        |                               |     Owner     |
     |        |<-(B)-- Authorization Grant ---|               |
     |        |                               +---------------+
     |        |
     |        |                               +---------------+
     | Client |--(C)-- Authorization Grant -->| Authorization |
     |        |                               |     Server    |
     |        |<-(D)----- Access Token -------|               |
     |        |                               +---------------+
     |        |
     |        |                               +---------------+
     |        |--(E)----- Access Token ------>|    Resource   |
     |        |                               |     Server    |
     |        |<-(F)--- Protected Resource ---|               |
     +--------+                               +---------------+
```

1. **(A)** Client が Resource Owner に認可を要求
2. **(B)** Resource Owner が認可グラント（許可証）を返す
3. **(C)** Client が認可グラントを Authorization Server に提示
4. **(D)** Authorization Server がアクセストークンを発行
5. **(E)** Client がアクセストークンを使ってリソースにアクセス
6. **(F)** Resource Server がリソースを返す

## 主要なエンドポイント

認可サーバーが公開する必要のあるエンドポイントは主に2つ。

### 1. 認可エンドポイント (`/authorize`)

- ユーザーがブラウザ経由でアクセスする
- ユーザーに同意画面を見せる
- 認可コードをクライアントにリダイレクトで渡す

### 2. トークンエンドポイント (`/token`)

- クライアントがサーバー間通信でアクセスする
- 認可コードやリフレッシュトークンと引き換えにアクセストークンを発行する
- Basic 認証またはクライアントシークレットで認証する

## トークンの種類

| トークン | 用途 | 有効期間 |
|---------|------|---------|
| Authorization Code | 認可コード。一時的な許可証 | 数分（通常10分以内） |
| Access Token | リソースへのアクセスに使う | 短い（数分〜1時間） |
| Refresh Token | アクセストークンの再取得に使う | 長い（数日〜数ヶ月） |

## スコープ

スコープはアクセス権限の範囲を定義する。

```
scope = "read:profile write:posts"
```

- スペース区切りで複数指定可能
- クライアントが要求し、ユーザーが許可する
- トークンに紐づけて発行される

## 認証 vs 認可

この違いを正確に理解することが重要。

| 項目 | 認証 (Authentication) | 認可 (Authorization) |
|------|----------------------|---------------------|
| 問い | あなたは誰か？ | あなたに何を許可するか？ |
| 例 | パスワードログイン | 「写真の読み取りを許可」 |
| プロトコル | OpenID Connect | OAuth 2.0 |
| 結果 | ID トークン | アクセストークン |

OAuth 2.0 は認可のフレームワークだが、認可サーバーはユーザー認証も内部的に行う必要がある（ログイン画面でユーザーを識別するため）。

## 次章

[第2章: グラントタイプ別の認可フロー詳解](./02-grant-types.md) では、各グラントタイプの仕組みを詳しく見ていく。
